from flask import Flask
from flask_sqlalchemy import SQLAlchemy
from flask_migrate import Migrate
from flask import Flask, render_template
from flask_socketio import SocketIO
import os
import re
from collections import Counter
from string import punctuation
from math import sqrt
from sqlalchemy import create_engine

db_string = os.environ['DATABASE_URL']

db = create_engine(db_string)

# try:
#     db.execute('DROP TABLE words;')
# except:
#     pass
# try:
#     db.execute('DROP TABLE sentences;')
# except:
#     pass
# try:
#     db.execute('DROP TABLE associations;')
# except:
#     pass

# db.execute("CREATE TABLE words(id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY  , word TEXT UNIQUE)")
# db.execute("CREATE TABLE sentences(id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY , sentence TEXT UNIQUE, used INT NOT NULL DEFAULT 0)")
# db.execute("CREATE TABLE associations (id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY , word_id INT NOT NULL, sentence_id INT NOT NULL, weight REAL NOT NULL)")
db.execute("CREATE TABLE IF NOT EXISTS words(id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY, word TEXT UNIQUE)")
db.execute("CREATE TABLE IF NOT EXISTS sentences(id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY, sentence TEXT UNIQUE, used INT NOT NULL DEFAULT 0)")
db.execute("CREATE TABLE IF NOT EXISTS associations (id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY, word_id INT NOT NULL, sentence_id INT NOT NULL, weight REAL NOT NULL)")

db.execute("CREATE TABLE IF NOT EXISTS conversations (id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY, input TEXT, response TEXT)")

app = Flask(__name__)

def get_id(entityName, text):
    tableName = entityName + 's'
    columnName = entityName
    r = db.execute('SELECT id FROM ' + tableName + ' WHERE ' + columnName + " = '" + text +"'")
    for ri in r:
        r = ri[0]
        break
    if not isinstance(r, int):
        db.execute('INSERT INTO ' + tableName + ' (' + columnName + ") VALUES ('" + text+ "')")
        r = db.execute('SELECT id FROM ' + tableName + ' ORDER BY id DESC LIMIT 1')
        for ri in r:
            r = ri[0]
            break
    return r

def get_words(text):
    wordsRegexpString = '(?:\w+|[' + re.escape(punctuation) + ']+)'
    wordsRegexp = re.compile(wordsRegexpString)
    wordsList = wordsRegexp.findall(text.lower())
    return Counter(wordsList).items()

B = 'Hello!'
def response(B,H):
    if H == '':
        return ''

    # finding the sentence having the largest 'association' with the input sentence
    try: db.execute('DROP TABLE results')
    except: pass
    db.execute('CREATE TABLE results(sentence_id INT, sentence TEXT, weight REAL)')
    words = get_words(H)
    words_length = sum([n * len(word) for word, n in words])
    for word, n in words:
        weight = sqrt(n / float(words_length))
        db.execute('INSERT INTO results SELECT associations.sentence_id, sentences.sentence, '+str(weight)+"*associations.weight/(4+sentences.used) AS weight FROM words INNER JOIN associations ON associations.word_id=words.id INNER JOIN sentences ON sentences.id=associations.sentence_id WHERE words.word='"+ word+"'")
    
    # if matches were found, give the best one
    try:
        r = db.execute('SELECT sentence_id, sentence, SUM(weight) AS sum_weight FROM results GROUP BY sentence_id, sentence ORDER BY sum_weight DESC LIMIT 1')
    except:
        r = db.execute('SELECT id, sentence FROM sentences WHERE used = (SELECT MIN(used) FROM sentences) ORDER BY RANDOM() LIMIT 1')
    for ri in r:
        r = ri
        break
    db.execute("UPDATE sentences SET used=used+1 WHERE id='"+str(r[0])+"'")
    
    # add association into database
    words = get_words(B)
    words_length = sum([n * len(word) for word, n in words])
    sentence_id = get_id('sentence', H)
    for word, n in words:
        word_id = get_id('word', word)
        weight = sqrt(n / float(words_length))
        db.execute("INSERT INTO associations (word_id, sentence_id, weight) VALUES ('" +str(word_id)+ "', '"+str(sentence_id)+ "', '" +str(weight)+ "')")
    return r[1]


socketio = SocketIO(app)

@app.route('/')
def sessions():
    return render_template('session.html')

def messageReceived(methods=['GET', 'POST']):
    print('message was received!!!')

@socketio.on('my event')
def handle_my_custom_event(json, methods=['GET', 'POST']):
    print('received my event: ' + str(json))
    global B
    try:
        json['bot_message'] = response(B, json['message'])
        B = json['bot_message']
        if json['message']:
            db.execute("INSERT INTO conversations ( input, response) VALUES ('" + str(json['message']) + "','" + str(json['bot_message']) +"')")
    except:
        pass
    socketio.emit('my response', json, callback=messageReceived)

if __name__ == '__main__':
    socketio.run(app, debug=True)

